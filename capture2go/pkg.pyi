# SPDX-FileCopyrightText: 2025 SensorStim Neurotechnology GmbH <support@capture2go.com>
#
# SPDX-License-Identifier: MIT

# WARNING: This file is automatically generated. Do not edit manually!

import ctypes
from typing import Final, Generic, Self, Type, TypeVar, TypedDict, Literal
import enum
import math
# import struct
# import zlib

import numpy as np


class DummyTypedDict(TypedDict):
    pass


# packages = {}  # dict that maps from header (integer) to class type
T_AbstractPackage = TypeVar('T_AbstractPackage', bound='AbstractPackage')
T_ParsedData = TypeVar('T_ParsedData', bound=DummyTypedDict)


packages: dict['SensorHeader', Type['AbstractPackage']]


def register_package(cls: Type[T_AbstractPackage]) -> Type[T_AbstractPackage]: ...


# Note: This does not inherit from ctypes.Structure on purpose to improve type hints.
class AbstractPackage(Generic[T_ParsedData]):
    header: 'SensorHeader' | None

    @classmethod
    def frombytes(cls, val) -> Self: ...

    def pack(self, header: 'SensorHeader | None' = None) -> bytes: ...

    def parse(self) -> T_ParsedData: ...

    def __bytes__(self) -> bytes: ...


MAX_PAYLOAD_SIZE: Final[int] = 236
MAX_PKG_SIZE: Final[int] = 244
GYR_SCALE_FACTOR: Final[float] = np.deg2rad(2000.0) / 32768.0
ACC_SCALE_FACTOR: Final[float] = 16.0 / 32768.0 * 9.81
MAG_SCALE_FACTOR: Final[float] = 1.0 / 16.0
DELTA_SCALE_FACTOR: Final[float] = math.pi / 32768.0
GYR_BIAS_SCALE_FACTOR: Final[float] = np.deg2rad(2.0) / 32768.0


# IMU data error flags (member errorFlags)
ERROR_FLAG_TIME_GAP: Final[int] = 0x01
ERROR_FLAG_GYR_CLIPPING: Final[int] = 0x02
ERROR_FLAG_ACC_CLIPPING: Final[int] = 0x04
ERROR_FLAG_MAG_CLIPPING: Final[int] = 0x08
ERROR_FLAG_PROCESSING_ISSUE: Final[int] = 0x10


@enum.unique
class SensorHeader(enum.IntEnum):
    CMD_GET_DEVICE_INFO = 0x0070
    """Requests device information."""
    DATA_DEVICE_INFO = 0x0071
    """Device information."""

    _RESERVED01 = 0x00A0
    _RESERVED02 = 0x00A1
    _RESERVED03 = 0x0103
    _RESERVED04 = 0x0104
    _RESERVED05 = 0x0105
    _RESERVED06 = 0x0106

    # Sleep and deep sleep
    CMD_SLEEP = 0x0110
    """Puts device into sleep mode."""
    ACK_SLEEP = 0x0111
    """Acknowledges sleep command."""
    CMD_DEEP_SLEEP = 0x0112
    """Puts device into deep sleep mode (transport mode)."""
    ACK_DEEP_SLEEP = 0x0113
    """Acknowledges deep sleep command."""

    # Main measurement configuration
    CMD_SET_MEASUREMENT_MODE = 0x0120
    """Sets measurement mode."""
    CMD_GET_MEASUREMENT_MODE = 0x0121
    """Requests measurement mode."""
    DATA_MEASUREMENT_MODE = 0x0122
    """Measurement mode."""

    # Burst measurement
    CMD_SET_MEASUREMENT_BURST_MODE = 0x0123
    """Sets measurement burst mode."""
    CMD_GET_MEASUREMENT_BURST_MODE = 0x0124
    """Requests measurement burst mode."""
    DATA_MEASUREMENT_BURST_MODE = 0x0125
    """Measurement burst mode."""

    _RESERVED07 = 0x0130
    _RESERVED08 = 0x0131
    _RESERVED09 = 0x0132

    # Recording configuration
    CMD_SET_RECORDING_CONFIG = 0x0140
    """Sets recording configuration."""
    CMD_GET_RECORDING_CONFIG = 0x0141
    """Requests recording configuration."""
    DATA_RECORDING_CONFIG = 0x0142
    """Recording configuration."""

    # Start and stop measurement
    CMD_START_STREAMING = 0x0150
    """Starts data streaming."""
    ACK_START_STREAMING = 0x0151
    """Acknowledges start streaming command."""
    CMD_STOP_STREAMING = 0x0152
    """Stops data streaming."""
    ACK_STOP_STREAMING = 0x0153
    """Acknowledges stop streaming command."""
    CMD_START_RECORDING = 0x0154
    """Starts recording data to internal storage."""
    ACK_START_RECORDING = 0x0155
    """Acknowledges start recording command."""
    CMD_STOP_RECORDING = 0x0156
    """Stops data recording."""
    ACK_STOP_RECORDING = 0x0157
    """Acknowledges stop recording command."""
    CMD_STOP_STREAMING_AND_CLEAR_BUFFER = 0x0158
    """
    Stops streaming and clears the send buffer. Used after connecting to a sensor in streaming mode. Note: Clearing the
    buffer can cause partial packages to be sent, which must be handled when unpacking.
    """
    ACK_STOP_STREAMING_AND_CLEAR_BUFFER = 0x0159
    """Acknowledges stop streaming and clear buffer command."""

    # Streaming via the real-time channel
    CMD_START_REAL_TIME_STREAMING = 0x0160
    """Starts real-time data streaming via dedicated channel."""
    CMD_GET_REAL_TIME_STREAMING_MODE = 0x0161
    """Requests current real-time streaming mode."""
    DATA_REAL_TIME_STREAMING_MODE = 0x0162
    """Real-time streaming mode."""
    CMD_STOP_REAL_TIME_STREAMING = 0x0163
    """Stops real-time data streaming."""
    ACK_STOP_REAL_TIME_STREAMING = 0x0164
    """Acknowledges stop real-time streaming command."""

    # Clock
    CMD_SET_ABSOLUTE_TIME = 0x0170
    """Sets the absolute time on the device. Sent from host to sync sender."""
    DATA_ABSOLUTE_TIME = 0x0171
    """Absolute time."""
    DATA_CLOCK_ROUNDTRIP = 0x0172
    """Clock roundtrip package for clock drift estimation."""

    # LED
    CMD_SET_LED_CONFIG = 0x0180
    """Sets LED configuration parameters."""
    CMD_GET_LED_CONFIG = 0x0181
    """Requests LED configuration parameters."""
    DATA_LED_CONFIG = 0x0182
    """LED configuration parameters."""
    CMD_SET_LED_MODE = 0x0183
    """Sets LED mode."""
    CMD_GET_LED_MODE = 0x0184
    """Requests LED mode."""
    DATA_LED_MODE = 0x0185
    """LED mode."""

    # Sync output
    CMD_SET_SYNC_OUTPUT_MODE = 0x0186
    """Configures a sync output pulse."""
    DATA_SYNC_OUTPUT_MODE = 0x0187
    """Sync output pulse configuration."""

    _RESERVED10 = 0x0190
    _RESERVED11 = 0x0191
    _RESERVED12 = 0x0192
    _RESERVED13 = 0x0193
    _RESERVED14 = 0x0194
    _RESERVED15 = 0x0195

    # Status
    CMD_GET_STATUS = 0x0200
    """Requests current device status information."""
    DATA_STATUS = 0x0201
    """Device status."""

    _RESERVED16 = 0x0210
    _RESERVED17 = 0x0211
    _RESERVED18 = 0x0212
    _RESERVED19 = 0x0213
    _RESERVED20 = 0x0214

    # Sensor data
    DATA_FULL_PACKED_200HZ = 0x0221
    """Full IMU data at 200 Hz, 8 samples, packaged at 25 Hz (200/8 Hz)."""
    DATA_FULL_PACKED_100HZ = 0x0222
    """Full IMU data at 100 Hz, 8 samples, packaged at 12.5 Hz (100/8 Hz)."""
    DATA_FULL_PACKED_50HZ = 0x0223
    """Full IMU data at 50 Hz, 8 samples, packaged at 6.25 Hz (50/8 Hz)."""
    DATA_FULL_PACKED_25HZ = 0x0224
    """Full IMU data at 25 Hz, 8 samples, packaged at 3.125 Hz (25/8 Hz)."""
    DATA_FULL_PACKED_10HZ = 0x0225
    """Full IMU data at 10 Hz, 8 samples, packaged at 1.25 Hz (10/8 Hz)."""
    DATA_FULL_PACKED_1HZ = 0x0226
    """Full IMU data at 1 Hz, 8 samples, packaged at 0.125 Hz (1/8 Hz)."""

    DATA_FULL_6D_PACKED_200HZ = 0x0231
    """IMU data without magnetometer at 200 Hz, 8 samples, packaged at 25 Hz (200/8 Hz)."""
    DATA_FULL_6D_PACKED_100HZ = 0x0232
    """IMU data without magnetometer at 100 Hz, 8 samples, packaged at 12.5 Hz (100/8 Hz)."""
    DATA_FULL_6D_PACKED_50HZ = 0x0233
    """IMU data without magnetometer at 50 Hz, 8 samples, packaged at 6.25 Hz (50/8 Hz)."""
    DATA_FULL_6D_PACKED_25HZ = 0x0234
    """IMU data without magnetometer at 25 Hz, 8 samples, packaged at 3.125 Hz (25/8 Hz)."""
    DATA_FULL_6D_PACKED_10HZ = 0x0235
    """IMU data without magnetometer at 10 Hz, 8 samples, packaged at 1.25 Hz (10/8 Hz)."""
    DATA_FULL_6D_PACKED_1HZ = 0x0236
    """IMU data without magnetometer at 1 Hz, 8 samples, packaged at 0.125 Hz (1/8 Hz)."""

    DATA_FULL_FIXED_200HZ = 0x0241
    """Full IMU data sample at 200 Hz, fixed-point format."""
    DATA_FULL_FIXED_100HZ = 0x0242
    """Full IMU data sample at 100 Hz, fixed-point format."""
    DATA_FULL_FIXED_50HZ = 0x0243
    """Full IMU data sample at 50 Hz, fixed-point format."""
    DATA_FULL_FIXED_25HZ = 0x0244
    """Full IMU data sample at 25 Hz, fixed-point format."""
    DATA_FULL_FIXED_10HZ = 0x0245
    """Full IMU data sample at 10 Hz, fixed-point format."""
    DATA_FULL_FIXED_1HZ = 0x0246
    """Full IMU data sample at 1 Hz, fixed-point format."""
    DATA_FULL_FIXED_RT = 0x0247
    """Full IMU data sample for real-time transmission, fixed-point format."""

    DATA_FULL_6D_FIXED_200HZ = 0x0251
    """IMU data sample without magnetometer at 200 Hz, fixed-point format."""
    DATA_FULL_6D_FIXED_100HZ = 0x0252
    """IMU data sample without magnetometer at 100 Hz, fixed-point format."""
    DATA_FULL_6D_FIXED_50HZ = 0x0253
    """IMU data sample without magnetometer at 50 Hz, fixed-point format."""
    DATA_FULL_6D_FIXED_25HZ = 0x0254
    """IMU data sample without magnetometer at 25 Hz, fixed-point format."""
    DATA_FULL_6D_FIXED_10HZ = 0x0255
    """IMU data sample without magnetometer at 10 Hz, fixed-point format."""
    DATA_FULL_6D_FIXED_1HZ = 0x0256
    """IMU data sample without magnetometer at 1 Hz, fixed-point format."""

    DATA_FULL_FLOAT_200HZ = 0x0261
    """Full IMU data sample at 200 Hz, floating-point format."""

    DATA_QUAT_PACKED_200HZ = 0x0271
    """Orientation data at 200 Hz, 20 samples, packaged at 10 Hz (200/20 Hz)."""
    DATA_QUAT_PACKED_100HZ = 0x0272
    """Orientation data at 100 Hz, 20 samples, packaged at 5 Hz (100/20 Hz)."""
    DATA_QUAT_PACKED_50HZ = 0x0273
    """Orientation data at 50 Hz, 20 samples, packaged at 2.5 Hz (50/20 Hz)."""
    DATA_QUAT_PACKED_25HZ = 0x0274
    """Orientation data at 25 Hz, 20 samples, packaged at 1.25 Hz (25/20 Hz)."""
    DATA_QUAT_PACKED_10HZ = 0x0275
    """Orientation data at 10 Hz, 20 samples, packaged at 0.5 Hz (10/20 Hz)."""
    DATA_QUAT_PACKED_1HZ = 0x0276
    """Orientation data at 1 Hz, 20 samples, packaged at 0.05 Hz (1/20 Hz)."""

    DATA_QUAT_FIXED_200HZ = 0x0281
    """Orientation data sample at 200 Hz, fixed-point format."""
    DATA_QUAT_FIXED_100HZ = 0x0282
    """Orientation data sample at 100 Hz, fixed-point format."""
    DATA_QUAT_FIXED_50HZ = 0x0283
    """Orientation data sample at 50 Hz, fixed-point format."""
    DATA_QUAT_FIXED_25HZ = 0x0284
    """Orientation data sample at 25 Hz, fixed-point format."""
    DATA_QUAT_FIXED_10HZ = 0x0285
    """Orientation data sample at 10 Hz, fixed-point format."""
    DATA_QUAT_FIXED_1HZ = 0x0286
    """Orientation data sample at 1 Hz, fixed-point format."""
    DATA_QUAT_FIXED_RT = 0x0287
    """Orientation data sample for real-time transmission, fixed-point format."""

    DATA_QUAT_FLOAT_200HZ = 0x0291
    """Orientation data sample at 200 Hz, floating-point format."""
    DATA_QUAT_FLOAT_100HZ = 0x0292
    """Orientation data sample at 100 Hz, floating-point format."""
    DATA_QUAT_FLOAT_50HZ = 0x0293
    """Orientation data sample at 50 Hz, floating-point format."""
    DATA_QUAT_FLOAT_25HZ = 0x0294
    """Orientation data sample at 25 Hz, floating-point format."""
    DATA_QUAT_FLOAT_10HZ = 0x0295
    """Orientation data sample at 10 Hz, floating-point format."""
    DATA_QUAT_FLOAT_1HZ = 0x0296
    """Orientation data sample at 1 Hz, floating-point format."""

    DATA_RAW_BURST = 0x0300
    """Raw sensor burst data at ~1666 Hz."""
    DATA_ACCZ_BURST = 0x0301
    """Accelerometer z-axis burst data at ~1666 Hz."""

    _RESERVED21 = 0x0310
    _RESERVED22 = 0x0311
    _RESERVED23 = 0x0312

    # Hardware sync input
    DATA_SYNC_TRIGGER = 0x0400
    """Received hardware synchronization trigger event."""

    CMD_FS_LIST_FILES = 0x0500
    """Requests a list of all files on the sensor."""
    DATA_FS_FILE_COUNT = 0x0501
    """Number of files on the sensor."""
    DATA_FS_FILE = 0x0502
    """Information about one file on the sensors."""

    CMD_FS_GET_BYTES = 0x0503
    """Requests contents of a file on the sensor."""
    DATA_FS_BYTES = 0x0504
    """Contents a file on the sensor."""

    CMD_FS_STOP_GET_BYTES = 0x0505
    """Stops getting contents from a file."""
    ACK_FS_STOP_GET_BYTES = 0x0506
    """Acknowledges stop getting bytes command."""

    CMD_FS_GET_SIZE = 0x0507
    """Requests the size of a file on the sensor."""
    DATA_FS_SIZE = 0x0508
    """Size of a file on the sensor."""

    CMD_FS_DELETE_FILE = 0x0509
    """Deletes a file on the sensor."""
    ACK_FS_DELETE_FILE = 0x050A
    """Acknowledges file deletion command."""
    CMD_FS_FORMAT_FILESYSTEM = 0x050D
    """Formats the filesystem."""
    ACK_FS_FORMAT_FILESYSTEM = 0x050E
    """Acknowledges filesystem format command."""

    _RESERVED24 = 0x1000
    _RESERVED25 = 0xFF00

    # Error
    ERROR = 0xFFFF
    """General error message from device."""


# classes for commands that do not have a payload (i.e., there is no corresponding struct):


class CmdGetDeviceInfo(AbstractPackage):
    header = SensorHeader.CMD_GET_DEVICE_INFO
    """SensorHeader.CMD_GET_DEVICE_INFO (0x0070)"""


class CmdSleep(AbstractPackage):
    header = SensorHeader.CMD_SLEEP
    """SensorHeader.CMD_SLEEP (0x0110)"""


class AckSleep(AbstractPackage):
    header = SensorHeader.ACK_SLEEP
    """SensorHeader.ACK_SLEEP (0x0111)"""


class CmdDeepSleep(AbstractPackage):
    header = SensorHeader.CMD_DEEP_SLEEP
    """SensorHeader.CMD_DEEP_SLEEP (0x0112)"""


class AckDeepSleep(AbstractPackage):
    header = SensorHeader.ACK_DEEP_SLEEP
    """SensorHeader.ACK_DEEP_SLEEP (0x0113)"""


class CmdGetMeasurementMode(AbstractPackage):
    header = SensorHeader.CMD_GET_MEASUREMENT_MODE
    """SensorHeader.CMD_GET_MEASUREMENT_MODE (0x0121)"""


class CmdGetMeasurementBurstMode(AbstractPackage):
    header = SensorHeader.CMD_GET_MEASUREMENT_BURST_MODE
    """SensorHeader.CMD_GET_MEASUREMENT_BURST_MODE (0x0124)"""


class CmdGetRecordingConfig(AbstractPackage):
    header = SensorHeader.CMD_GET_RECORDING_CONFIG
    """SensorHeader.CMD_GET_RECORDING_CONFIG (0x0141)"""


class CmdStartStreaming(AbstractPackage):
    header = SensorHeader.CMD_START_STREAMING
    """SensorHeader.CMD_START_STREAMING (0x0150)"""


class AckStartStreaming(AbstractPackage):
    header = SensorHeader.ACK_START_STREAMING
    """SensorHeader.ACK_START_STREAMING (0x0151)"""


class CmdStopStreaming(AbstractPackage):
    header = SensorHeader.CMD_STOP_STREAMING
    """SensorHeader.CMD_STOP_STREAMING (0x0152)"""


class AckStopStreaming(AbstractPackage):
    header = SensorHeader.ACK_STOP_STREAMING
    """SensorHeader.ACK_STOP_STREAMING (0x0153)"""


class CmdStartRecording(AbstractPackage):
    header = SensorHeader.CMD_START_RECORDING
    """SensorHeader.CMD_START_RECORDING (0x0154)"""


class AckStartRecording(AbstractPackage):
    header = SensorHeader.ACK_START_RECORDING
    """SensorHeader.ACK_START_RECORDING (0x0155)"""


class CmdStopRecording(AbstractPackage):
    header = SensorHeader.CMD_STOP_RECORDING
    """SensorHeader.CMD_STOP_RECORDING (0x0156)"""


class AckStopRecording(AbstractPackage):
    header = SensorHeader.ACK_STOP_RECORDING
    """SensorHeader.ACK_STOP_RECORDING (0x0157)"""


class CmdStopStreamingAndClearBuffer(AbstractPackage):
    header = SensorHeader.CMD_STOP_STREAMING_AND_CLEAR_BUFFER
    """SensorHeader.CMD_STOP_STREAMING_AND_CLEAR_BUFFER (0x0158)"""


class AckStopStreamingAndClearBuffer(AbstractPackage):
    header = SensorHeader.ACK_STOP_STREAMING_AND_CLEAR_BUFFER
    """SensorHeader.ACK_STOP_STREAMING_AND_CLEAR_BUFFER (0x0159)"""


class CmdGetRealTimeStreamingMode(AbstractPackage):
    header = SensorHeader.CMD_GET_REAL_TIME_STREAMING_MODE
    """SensorHeader.CMD_GET_REAL_TIME_STREAMING_MODE (0x0161)"""


class CmdStopRealTimeStreaming(AbstractPackage):
    header = SensorHeader.CMD_STOP_REAL_TIME_STREAMING
    """SensorHeader.CMD_STOP_REAL_TIME_STREAMING (0x0163)"""


class AckStopRealTimeStreaming(AbstractPackage):
    header = SensorHeader.ACK_STOP_REAL_TIME_STREAMING
    """SensorHeader.ACK_STOP_REAL_TIME_STREAMING (0x0164)"""


class CmdGetLedConfig(AbstractPackage):
    header = SensorHeader.CMD_GET_LED_CONFIG
    """SensorHeader.CMD_GET_LED_CONFIG (0x0181)"""


class CmdGetLedMode(AbstractPackage):
    header = SensorHeader.CMD_GET_LED_MODE
    """SensorHeader.CMD_GET_LED_MODE (0x0184)"""


class CmdGetStatus(AbstractPackage):
    header = SensorHeader.CMD_GET_STATUS
    """SensorHeader.CMD_GET_STATUS (0x0200)"""


class CmdFsListFiles(AbstractPackage):
    header = SensorHeader.CMD_FS_LIST_FILES
    """SensorHeader.CMD_FS_LIST_FILES (0x0500)"""


class CmdFsStopGetBytes(AbstractPackage):
    header = SensorHeader.CMD_FS_STOP_GET_BYTES
    """SensorHeader.CMD_FS_STOP_GET_BYTES (0x0505)"""


class AckFsStopGetBytes(AbstractPackage):
    header = SensorHeader.ACK_FS_STOP_GET_BYTES
    """SensorHeader.ACK_FS_STOP_GET_BYTES (0x0506)"""


class CmdFsFormatFilesystem(AbstractPackage):
    header = SensorHeader.CMD_FS_FORMAT_FILESYSTEM
    """SensorHeader.CMD_FS_FORMAT_FILESYSTEM (0x050D)"""


class AckFsFormatFilesystem(AbstractPackage):
    header = SensorHeader.ACK_FS_FORMAT_FILESYSTEM
    """SensorHeader.ACK_FS_FORMAT_FILESYSTEM (0x050E)"""


# remaining content of package.hpp:

@enum.unique
class ErrorCode(enum.IntEnum):
    NO_ERROR = 0x00
    """No error occurred."""
    FILE_NOT_FOUND = 0xF0
    """File was not found."""
    FILE_DELETION_FAILED = 0xF1
    """File deletion failed."""
    FILE_SYSTEM_ERROR = 0xF2
    """File system error occurred."""
    FILE_ALREADY_EXISTS = 0xF3
    """File already exists."""
    FILE_TOO_SHORT = 0xF4
    """File is too short."""
    FILE_NAME_INVALID = 0xF5
    """File name is invalid."""
    FILE_SYSTEM_FULL = 0xF6
    """File system is full."""
    RECORDING_CONFIG_NOT_SET = 0xF9
    """Recording configuration is not set."""
    CALIB_PARAM_FLASH_ERROR = 0xFA
    """Error when flashing calibration parameters."""
    WRONG_STATE = 0xFB
    """Device is in the wrong state."""
    PKG_ERROR = 0xFC
    """Could not parse received package."""
    UNKNOWN_COMMAND = 0xFD
    """Unknown command received."""
    SEND_BUFFER_FULL = 0xFE
    """Send buffer is full."""
    UNKNOWN_ERROR = 0xFF
    """An unknown error occurred."""


@enum.unique
class SensorState(enum.IntEnum):
    OFF = 0
    """Sensor is powered off."""
    IDLE = enum.auto()
    """Sensor is idle."""
    STREAMING = enum.auto()
    """Sensor is streaming data."""
    RECORDING = enum.auto()
    """Sensor is recording data."""


@enum.unique
class ConnectionState(enum.IntEnum):
    OFFLINE = 0
    """Device is offline."""
    ADVERTISING = enum.auto()
    """Device is advertising via BLE."""
    BLE_CONNECTED = enum.auto()
    """Device is connected via BLE."""
    USB_CONNECTED = enum.auto()
    """Device is connected via USB."""


@enum.unique
class SamplingMode(enum.IntEnum):
    MODE_DISABLED = 0x00
    """Disabled."""
    MODE_200HZ = 0x01
    """Sampling at 200 Hz."""
    MODE_100HZ = 0x02
    """Sampling at 100 Hz."""
    MODE_50HZ = 0x03
    """Sampling at 50 Hz."""
    MODE_25HZ = 0x04
    """Sampling at 25 Hz."""
    MODE_10HZ = 0x05
    """Sampling at 10 Hz."""
    MODE_1HZ = 0x06
    """Sampling at 1 Hz."""


@enum.unique
class SyncMode(enum.IntEnum):
    NO_SYNC = 0x00
    """Synchronization is disabled."""
    SYNC_SENDER = 0x01
    """Device is a sync sender."""
    SYNC_RECEIVER = 0x02
    """Device is a sync receiver."""


@enum.unique
class ProcessExtensionMode(enum.IntEnum):
    NO_EXTENSION = 0x0000
    """No processing extension."""
    _RESERVED01 = 0x0101


@enum.unique
class CalibrationDataMode(enum.IntEnum):
    CALIB_DATA_DISABLED = 0x00
    """Calibration data is disabled."""
    CALIB_DATA_FULL = 0x01
    """Full calibration data is generated."""
    CALIB_DATA_MAG = 0x02
    """Magnetometer calibration data is generated."""


@enum.unique
class RealTimeDataMode(enum.IntEnum):
    REAL_TIME_DATA_DISABLED = 0x00
    """Real-time data is disabled."""
    REAL_TIME_DATA_QUAT = 0x01
    """Send ``DataQuatFixedRt`` packages via the real-time channel."""
    REAL_TIME_DATA_FULL = 0x02
    """Send ``DataFullFixedRt`` packages via the real-time channel."""


class ParsedDataDeviceInfo(TypedDict):
    protocolVersion: int
    serial: str
    hardwareRevision: str
    firmwareRevision: str
    firmwareVersion: str
    firmwareDate: str


class DataDeviceInfo(AbstractPackage[ParsedDataDeviceInfo]):
    """
    Device information such as protocol version, serial, hardware and firmware details.

    **Fields**:

    * **protocolVersion**: *uint16* -- Protocol version, currently 1. Values >= 32768 (0x8000) are reserved for
      custom applications.
    * **serial**: *char[6]* -- Device serial.
    * **hardwareRevision**: *char[8]* -- Hardware revision string.
    * **firmwareRevision**: *char[8]* -- Firmware revision string.
    * **firmwareVersion**: *char[12]* -- Firmware version string.
    * **firmwareDate**: *char[11]* -- Firmware build date.

    2 + 6 + 8 + 8 + 12 + 11 = 47 bytes
    """
    header = SensorHeader.DATA_DEVICE_INFO
    """SensorHeader.DATA_DEVICE_INFO (0x0071)"""

    protocolVersion: int
    """uint16; Protocol version, currently 1. Values >= 32768 (0x8000) are reserved for custom applications."""
    serial: bytes
    """char[6]; Device serial."""
    hardwareRevision: bytes
    """char[8]; Hardware revision string."""
    firmwareRevision: bytes
    """char[8]; Firmware revision string."""
    firmwareVersion: bytes
    """char[12]; Firmware version string."""
    firmwareDate: bytes
    """char[11]; Firmware build date."""

    def __init__(
        self,
        protocolVersion: int = ...,
        serial: bytes = ...,
        hardwareRevision: bytes = ...,
        firmwareRevision: bytes = ...,
        firmwareVersion: bytes = ...,
        firmwareDate: bytes = ...,
    ) -> None: ...


class ParsedDataMeasurementMode(TypedDict):
    timestamp: int
    fullFloat200HzEnabled: bool
    fullFixedMode: SamplingMode
    fullPackedMode: SamplingMode
    quatFloatMode: SamplingMode
    quatFixedMode: SamplingMode
    quatPackedMode: SamplingMode
    statusMode: int
    calibDataMode: CalibrationDataMode
    processExtensionMode: ProcessExtensionMode
    syncMode: SyncMode
    syncId: int
    disableBiasEstimation: bool
    disableMagDistRejection: bool
    disableMagData: bool


class DataMeasurementMode(AbstractPackage[ParsedDataMeasurementMode]):
    """
    Configures the IMU measurement mode.

    The measurement mode determines which sensor data packages are generated, how synchronization is configured, and if
    bias estimation and magnetic disturbance rejection are enabled.

    The ``syncId`` should be set to a random 64 bit number that is re-generated whenever the set of employed sensors
    change. One device should be configured as sender and the other devices as receivers with the same ``syncId``.

    Note: The ``processExtensionMode`` is reserved for future use. Set to ``NO_EXTENSION`` (0) for now.

    **Fields**:

    * **timestamp**: *int64* -- Timestamp (in nanoseconds) when the mode is first applied. Set to 0 in
      ``CmdSetMeasurementMode`` to apply immediately or use a later timestamp to delay applying the new mode.
    * **fullFloat200HzEnabled**: *bool* -- Enables full float packages at 200 Hz.
    * **fullFixedMode**: *SamplingMode, uint8* -- Sampling mode for full fixed packages.
    * **fullPackedMode**: *SamplingMode, uint8* -- Sampling mode for full packed packaged.
    * **quatFloatMode**: *SamplingMode, uint8* -- Sampling mode for orientation float packages.
    * **quatFixedMode**: *SamplingMode, uint8* -- Sampling mode for orientation fixed packages.
    * **quatPackedMode**: *SamplingMode, uint8* -- Sampling mode for orientation packed packages.
    * **statusMode**: *uint8* -- Interval of status packages in seconds, 0 to disable. Recommended: 1 s.
    * **calibDataMode**: *CalibrationDataMode, uint8* -- Calibration data mode. For internal use only; set to 0.
    * **processExtensionMode**: *ProcessExtensionMode, uint16* -- Process extension mode.
    * **syncMode**: *SyncMode, uint8* -- Synchronization mode.
    * **syncId**: *uint64* -- Synchronization ID.
    * **disableBiasEstimation**: *bool* -- If true, rest detection and online bias estimation are not performed.
    * **disableMagDistRejection**: *bool* -- If true, magnetic disturbance rejection is not performed.
    * **disableMagData**: *bool* -- If true, the full packed/fixed modes will generate the 6D variants without
      magnetometer data.

    8 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 2 + 1 + 8 + 1 + 1 + 1 = 30 bytes
    """
    header = SensorHeader.DATA_MEASUREMENT_MODE
    """SensorHeader.DATA_MEASUREMENT_MODE (0x0122)"""

    timestamp: int
    """
    int64; Timestamp (in nanoseconds) when the mode is first applied. Set to 0 in ``CmdSetMeasurementMode`` to apply
    immediately or use a later timestamp to delay applying the new mode.
    """
    fullFloat200HzEnabled: bool
    """bool; Enables full float packages at 200 Hz."""
    fullFixedMode: SamplingMode
    """SamplingMode; Sampling mode for full fixed packages."""
    fullPackedMode: SamplingMode
    """SamplingMode; Sampling mode for full packed packaged."""
    quatFloatMode: SamplingMode
    """SamplingMode; Sampling mode for orientation float packages."""
    quatFixedMode: SamplingMode
    """SamplingMode; Sampling mode for orientation fixed packages."""
    quatPackedMode: SamplingMode
    """SamplingMode; Sampling mode for orientation packed packages."""
    statusMode: int
    """uint8; Interval of status packages in seconds, 0 to disable. Recommended: 1 s."""
    calibDataMode: CalibrationDataMode
    """CalibrationDataMode; Calibration data mode. For internal use only; set to 0."""
    processExtensionMode: ProcessExtensionMode
    """ProcessExtensionMode; Process extension mode."""
    syncMode: SyncMode
    """SyncMode; Synchronization mode."""
    syncId: int
    """uint64; Synchronization ID."""
    disableBiasEstimation: bool
    """bool; If true, rest detection and online bias estimation are not performed."""
    disableMagDistRejection: bool
    """bool; If true, magnetic disturbance rejection is not performed."""
    disableMagData: bool
    """bool; If true, the full packed/fixed modes will generate the 6D variants without magnetometer data."""

    def __init__(
        self,
        timestamp: int = ...,
        fullFloat200HzEnabled: bool = ...,
        fullFixedMode: SamplingMode = ...,
        fullPackedMode: SamplingMode = ...,
        quatFloatMode: SamplingMode = ...,
        quatFixedMode: SamplingMode = ...,
        quatPackedMode: SamplingMode = ...,
        statusMode: int = ...,
        calibDataMode: CalibrationDataMode = ...,
        processExtensionMode: ProcessExtensionMode = ...,
        syncMode: SyncMode = ...,
        syncId: int = ...,
        disableBiasEstimation: bool = ...,
        disableMagDistRejection: bool = ...,
        disableMagData: bool = ...,
    ) -> None: ...


class CmdSetMeasurementMode(DataMeasurementMode):
    header = SensorHeader.CMD_SET_MEASUREMENT_MODE
    """SensorHeader.CMD_SET_MEASUREMENT_MODE (0x0120)"""


class ParsedDataMeasurementBurstMode(TypedDict):
    enabled: bool
    startTimestamp: int
    endTimestamp: int
    endTimestampIsRelative: bool
    accZOnly: bool


class DataMeasurementBurstMode(AbstractPackage[ParsedDataMeasurementBurstMode]):
    """
    Configures the burst mode for short-term high-frequency measurements.

    The burst mode is meant for recording high-frequency IMU data at ~1666 Hz for a short period of time (around a
    second). The burst time window can be configured in advance. The sensor will store the last received
    DataMeasurementBurstMode and start the burst measurement as soon as the configured startTimestamp is reached.

    Note: Longer burst measurements might be possible, depending on the device connection and configured measurement
    mode, but this cannot be guaranteed.

    **Fields**:

    * **enabled**: *bool* -- Indicates if burst mode is enabled.
    * **startTimestamp**: *int64* -- Start timestamp (in nanoseconds) for burst mode.
    * **endTimestamp**: *int64* -- End timestamp (in nanoseconds) for burst mode. Set to 0 to disable, set to
      0x8000000000000000 (max int64) for continuous measurement.
    * **endTimestampIsRelative**: *bool* -- Indicates if end timestamp is relative to start.
    * **accZOnly**: *bool* -- If true, only the z-axis accelerometer data is saved.

    1 + 8 + 8 + 1 + 1 = 19 bytes
    """
    header = SensorHeader.DATA_MEASUREMENT_BURST_MODE
    """SensorHeader.DATA_MEASUREMENT_BURST_MODE (0x0125)"""

    enabled: bool
    """bool; Indicates if burst mode is enabled."""
    startTimestamp: int
    """int64; Start timestamp (in nanoseconds) for burst mode."""
    endTimestamp: int
    """
    int64; End timestamp (in nanoseconds) for burst mode. Set to 0 to disable, set to 0x8000000000000000 (max int64) for
    continuous measurement.
    """
    endTimestampIsRelative: bool
    """bool; Indicates if end timestamp is relative to start."""
    accZOnly: bool
    """bool; If true, only the z-axis accelerometer data is saved."""

    def __init__(
        self,
        enabled: bool = ...,
        startTimestamp: int = ...,
        endTimestamp: int = ...,
        endTimestampIsRelative: bool = ...,
        accZOnly: bool = ...,
    ) -> None: ...


class CmdSetMeasurementBurstMode(DataMeasurementBurstMode):
    header = SensorHeader.CMD_SET_MEASUREMENT_BURST_MODE
    """SensorHeader.CMD_SET_MEASUREMENT_BURST_MODE (0x0123)"""


class ParsedDataRecordingConfig(TypedDict):
    endTimestamp: int
    endTimestampIsRelative: bool
    filename: bytes


class DataRecordingConfig(AbstractPackage[ParsedDataRecordingConfig]):
    """
    Configures file name and automatic end for data recording to internal storage.

    **Fields**:

    * **endTimestamp**: *int64* -- End timestamp (in nanoseconds) for recording. 0 for open-end recording.
    * **endTimestampIsRelative**: *bool* -- If true, end timestamp is relative.
    * **filename**: *char[65]* -- File name for recording. Maximum file name length is 64 characters, the rest
      needs to be filled with zero bytes.

    8 + 1 + 65 = 74 bytes
    """
    header = SensorHeader.DATA_RECORDING_CONFIG
    """SensorHeader.DATA_RECORDING_CONFIG (0x0142)"""

    endTimestamp: int
    """int64; End timestamp (in nanoseconds) for recording. 0 for open-end recording."""
    endTimestampIsRelative: bool
    """bool; If true, end timestamp is relative."""
    filename: bytes
    """
    char[65]; File name for recording. Maximum file name length is 64 characters, the rest needs to be filled with zero
    bytes.
    """

    def __init__(
        self,
        endTimestamp: int = ...,
        endTimestampIsRelative: bool = ...,
        filename: bytes = ...,
    ) -> None: ...


class CmdSetRecordingConfig(DataRecordingConfig):
    header = SensorHeader.CMD_SET_RECORDING_CONFIG
    """SensorHeader.CMD_SET_RECORDING_CONFIG (0x0140)"""


class ParsedDataRealTimeStreamingMode(TypedDict):
    mode: RealTimeDataMode
    rateLimit: int


class DataRealTimeStreamingMode(AbstractPackage[ParsedDataRealTimeStreamingMode]):
    """
    Configures real-time data streaming.

    **Fields**:

    * **mode**: *RealTimeDataMode, uint8* -- Real-time data mode.
    * **rateLimit**: *uint8* -- Maximum sending frequency in Hz, set to 0 to use the default value (currently 50
      Hz).

    1 + 1 = 2 bytes
    """
    header = SensorHeader.DATA_REAL_TIME_STREAMING_MODE
    """SensorHeader.DATA_REAL_TIME_STREAMING_MODE (0x0162)"""

    mode: RealTimeDataMode
    """RealTimeDataMode; Real-time data mode."""
    rateLimit: int
    """uint8; Maximum sending frequency in Hz, set to 0 to use the default value (currently 50 Hz)."""

    def __init__(
        self,
        mode: RealTimeDataMode = ...,
        rateLimit: int = ...,
    ) -> None: ...


class CmdStartRealTimeStreaming(DataRealTimeStreamingMode):
    header = SensorHeader.CMD_START_REAL_TIME_STREAMING
    """SensorHeader.CMD_START_REAL_TIME_STREAMING (0x0160)"""


class ParsedDataAbsoluteTime(TypedDict):
    newTimestamp: int


class DataAbsoluteTime(AbstractPackage[ParsedDataAbsoluteTime]):
    """
    Absolute time to be applied to the sensor clock.

    Note: The acknowlegement to ``CmdSetAbsoluteTime`` is a ``DataAbsoluteTime`` package with the same timestamp.
    Otherwise, ``DataAbsoluteTime`` is not used. To get the current time on the sensor, look at the timestamps in the
    ``DataStatus`` or ``DataClockRoundtrip`` packages.

    **Fields**:

    * **newTimestamp**: *int64* -- New absolute timestamp (in nanoseconds).

    8 bytes
    """
    header = SensorHeader.DATA_ABSOLUTE_TIME
    """SensorHeader.DATA_ABSOLUTE_TIME (0x0171)"""

    newTimestamp: int
    """int64; New absolute timestamp (in nanoseconds)."""

    def __init__(
        self,
        newTimestamp: int = ...,
    ) -> None: ...


class CmdSetAbsoluteTime(DataAbsoluteTime):
    header = SensorHeader.CMD_SET_ABSOLUTE_TIME
    """SensorHeader.CMD_SET_ABSOLUTE_TIME (0x0170)"""


class ParsedDataClockRoundtrip(TypedDict):
    hostSendTimestamp: int
    sensorReceiveTimestamp: int
    sensorSendTimestamp: int
    hostReceiveTimestamp: int


class DataClockRoundtrip(AbstractPackage[ParsedDataClockRoundtrip]):
    """
    Clock roundtrip package for estimation of clock drift between host and sensors.

    To estimate clock drift between the host and the sensors, send this package regularly to the sensor (e.g., every
    second). When sending, set ``hostSendTimestamp`` to the current host time and the other 3 timestamps to zero.

    The sensor will set ``sensorReceiveTimestamp`` directly after receiving the package and ``sensorSendTimestamp``
    directly when sending the package.

    The host should then set ``hostReceiveTimestamp`` directly after receiving the package. (The Python SDK does this
    automatically.)

    Calculate ``(hostReceiveTimestamp + sensorReceiveTimestamp - hostSendTimestamp - sensorSendTimestamp)/2`` to
    estimate the transmission delay and ``(hostSendTimestamp + hostReceiveTimestamp - sensorReceiveTimestamp -
    sensorSendTimestamp)/2`` to estimate the host clock offset. Note that single samples will jitter significantly and
    outliers can occurr due to transmission issues.

    **Fields**:

    * **hostSendTimestamp**: *int64* -- Timestamp (in nanoseconds) when host sent the message.
    * **sensorReceiveTimestamp**: *int64* -- Timestamp (in nanoseconds) when sensor received the message.
    * **sensorSendTimestamp**: *int64* -- Timestamp (in nanoseconds) when sensor sent the response.
    * **hostReceiveTimestamp**: *int64* -- Timestamp (in nanoseconds) when host received the response.

    8 + 8 + 8 + 8 = 32 bytes
    """
    header = SensorHeader.DATA_CLOCK_ROUNDTRIP
    """SensorHeader.DATA_CLOCK_ROUNDTRIP (0x0172)"""

    hostSendTimestamp: int
    """int64; Timestamp (in nanoseconds) when host sent the message."""
    sensorReceiveTimestamp: int
    """int64; Timestamp (in nanoseconds) when sensor received the message."""
    sensorSendTimestamp: int
    """int64; Timestamp (in nanoseconds) when sensor sent the response."""
    hostReceiveTimestamp: int
    """int64; Timestamp (in nanoseconds) when host received the response."""

    def __init__(
        self,
        hostSendTimestamp: int = ...,
        sensorReceiveTimestamp: int = ...,
        sensorSendTimestamp: int = ...,
        hostReceiveTimestamp: int = ...,
    ) -> None: ...


class ParsedDataLedConfig(TypedDict):
    brightnessPercentage: int
    alternativeColors: bool
    notifyColor: int


class DataLedConfig(AbstractPackage[ParsedDataLedConfig]):
    """
    Configures the device LED.

    **Fields**:

    * **brightnessPercentage**: *uint8* -- LED brightness percentage (default: 40).
    * **alternativeColors**: *bool* -- If true, alternative LED colors are used (blue instead of green).
    * **notifyColor**: *uint32* -- Notification color RGB value (default: white, 0xFFFFFF).

    1 + 1 + 4 = 6 bytes
    """
    header = SensorHeader.DATA_LED_CONFIG
    """SensorHeader.DATA_LED_CONFIG (0x0182)"""

    brightnessPercentage: int
    """uint8; LED brightness percentage (default: 40)."""
    alternativeColors: bool
    """bool; If true, alternative LED colors are used (blue instead of green)."""
    notifyColor: int
    """uint32; Notification color RGB value (default: white, 0xFFFFFF)."""

    def __init__(
        self,
        brightnessPercentage: int = ...,
        alternativeColors: bool = ...,
        notifyColor: int = ...,
    ) -> None: ...


class CmdSetLedConfig(DataLedConfig):
    header = SensorHeader.CMD_SET_LED_CONFIG
    """SensorHeader.CMD_SET_LED_CONFIG (0x0180)"""


class ParsedDataLedMode(TypedDict):
    notifyStartTimestamp: int
    notifyEndTimestamp: int
    endTimestampIsRelative: bool


class DataLedMode(AbstractPackage[ParsedDataLedMode]):
    """
    Configures the LED notification light (typically white unless changed in ``DataLedConfig``).

    This is used by the app to flash the LED for one second at the start and end of the measurement.

    Note: The ``DataLedMode`` sent as a response to ``CmdSetLedMode`` will always contain the actual and absolute
    timestamps. Those timestamps can be used for example for synchronization of IMU data and a video that recorded the
    flashing LED.

    **Fields**:

    * **notifyStartTimestamp**: *int64* -- Start timestamp (in nanoseconds) for LED notification. Set to 0 for
      immediate start (if end timestamp is not 0), set both to 0 to disable.
    * **notifyEndTimestamp**: *int64* -- End timestamp (in nanoseconds) for LED notification. Set to 0 for
      unlimited duration (if end timestamp is not 0), set both to 0 to disable.
    * **endTimestampIsRelative**: *bool* -- If true, end timestamp is relative to the start.

    8 + 8 + 1 = 17 bytes
    """
    header = SensorHeader.DATA_LED_MODE
    """SensorHeader.DATA_LED_MODE (0x0185)"""

    notifyStartTimestamp: int
    """
    int64; Start timestamp (in nanoseconds) for LED notification. Set to 0 for immediate start (if end timestamp is not
    0), set both to 0 to disable.
    """
    notifyEndTimestamp: int
    """
    int64; End timestamp (in nanoseconds) for LED notification. Set to 0 for unlimited duration (if end timestamp is not
    0), set both to 0 to disable.
    """
    endTimestampIsRelative: bool
    """bool; If true, end timestamp is relative to the start."""

    def __init__(
        self,
        notifyStartTimestamp: int = ...,
        notifyEndTimestamp: int = ...,
        endTimestampIsRelative: bool = ...,
    ) -> None: ...


class CmdSetLedMode(DataLedMode):
    header = SensorHeader.CMD_SET_LED_MODE
    """SensorHeader.CMD_SET_LED_MODE (0x0183)"""


class ParsedDataSyncOutputMode(TypedDict):
    startTimestamp: int
    endTimestamp: int
    endTimestampIsRelative: bool


class DataSyncOutputMode(AbstractPackage[ParsedDataSyncOutputMode]):
    """
    Synchronization output mode configuration.

    Setting this pulls the USB-C sideband use pin (SBU) down for the configured duration. The resulting electrical
    signal can be used for precise time synchronization between the sensors and other systems or to automatically start
    or stop other measurement systems.

    The response to ``CmdSetSyncOutputMode`` is sent after the pulse is finished and includes precise and absolute
    timestamps.

    **Fields**:

    * **startTimestamp**: *int64* -- Start timestamp (in nanoseconds) for sync output. Set to 0 for immediate
      start (if end timestamp is not 0), set both to 0 to disable.
    * **endTimestamp**: *int64* -- End timestamp (in nanoseconds) for sync output. Set to 0 for unlimited duration
      (if end timestamp is not 0), set both to 0 to disable (max pulse duration 1 sec).
    * **endTimestampIsRelative**: *bool* -- If true, end timestamp is relative to the start.

    8 + 8 + 1 = 17 bytes
    """
    header = SensorHeader.DATA_SYNC_OUTPUT_MODE
    """SensorHeader.DATA_SYNC_OUTPUT_MODE (0x0187)"""

    startTimestamp: int
    """
    int64; Start timestamp (in nanoseconds) for sync output. Set to 0 for immediate start (if end timestamp is not 0),
    set both to 0 to disable.
    """
    endTimestamp: int
    """
    int64; End timestamp (in nanoseconds) for sync output. Set to 0 for unlimited duration (if end timestamp is not 0),
    set both to 0 to disable (max pulse duration 1 sec).
    """
    endTimestampIsRelative: bool
    """bool; If true, end timestamp is relative to the start."""

    def __init__(
        self,
        startTimestamp: int = ...,
        endTimestamp: int = ...,
        endTimestampIsRelative: bool = ...,
    ) -> None: ...


class CmdSetSyncOutputMode(DataSyncOutputMode):
    header = SensorHeader.CMD_SET_SYNC_OUTPUT_MODE
    """SensorHeader.CMD_SET_SYNC_OUTPUT_MODE (0x0186)"""


class ParsedDataStatus(TypedDict):
    timestamp: int
    sensorState: SensorState
    connectionState: ConnectionState
    gyrBias: np.ndarray[tuple[Literal[1], Literal[3]], np.dtype[np.float64]]
    synchronized: bool
    batteryPercentage: int
    isCharging: bool
    freeStoragePercentage: int


class DataStatus(AbstractPackage[ParsedDataStatus]):
    """
    Device status information.

    **Fields**:

    * **timestamp**: *int64* -- Timestamp (in nanoseconds).
    * **sensorState**: *SensorState, uint8* -- Current sensor state.
    * **connectionState**: *ConnectionState, uint8* -- Current connection state.
    * **gyrBias**: *int16[3]* -- Gyroscope bias estimate, fixed-point, 2°/s full range. The gyroscope measurements
      already have this bias removed.
    * **synchronized**: *bool* -- If true, device is either a sync sender or it is a sync receiver and received
      sufficient sync information recently.
    * **battery**: *uint8* -- Battery level in percent. When charging, 128 is added to the percentage.
    * **freeStoragePercentage**: *uint8* -- Free storage percentage.

    8 + 1 + 1 + 3*2 + 1 + 1 + 1 = 19 bytes
    """
    header = SensorHeader.DATA_STATUS
    """SensorHeader.DATA_STATUS (0x0201)"""

    timestamp: int
    """int64; Timestamp (in nanoseconds)."""
    sensorState: SensorState
    """SensorState; Current sensor state."""
    connectionState: ConnectionState
    """ConnectionState; Current connection state."""
    gyrBias: ctypes.Array[ctypes.c_int16]
    """
    int16[3]; Gyroscope bias estimate, fixed-point, 2°/s full range. The gyroscope measurements already have this bias
    removed.
    """
    synchronized: bool
    """
    bool; If true, device is either a sync sender or it is a sync receiver and received sufficient sync information
    recently.
    """
    battery: int
    """uint8; Battery level in percent. When charging, 128 is added to the percentage."""
    freeStoragePercentage: int
    """uint8; Free storage percentage."""

    def __init__(
        self,
        timestamp: int = ...,
        sensorState: SensorState = ...,
        connectionState: ConnectionState = ...,
        gyrBias: ctypes.Array[ctypes.c_int16] = ...,
        synchronized: bool = ...,
        battery: int = ...,
        freeStoragePercentage: int = ...,
    ) -> None: ...


class ParsedDataFullPacked(TypedDict):
    timestamp: np.ndarray[tuple[Literal[8], Literal[1]], np.dtype[np.float64]]
    gyr: np.ndarray[tuple[Literal[8], Literal[3]], np.dtype[np.float64]]
    acc: np.ndarray[tuple[Literal[8], Literal[3]], np.dtype[np.float64]]
    mag: np.ndarray[tuple[Literal[8], Literal[3]], np.dtype[np.float64]]
    quat: np.ndarray[tuple[Literal[8], Literal[4]], np.dtype[np.float64]]
    quat9D: np.ndarray[tuple[Literal[8], Literal[1]], np.dtype[np.float64]]
    delta: np.ndarray[tuple[Literal[8], Literal[1]], np.dtype[np.float64]]
    restDetected: np.ndarray[tuple[Literal[8], Literal[1]], np.dtype[np.bool]]
    magDistDetected: np.ndarray[tuple[Literal[8], Literal[1]], np.dtype[np.bool]]
    errorFlags: np.ndarray[tuple[Literal[8], Literal[1]], np.dtype[np.uint8]]


class DataFullPacked(AbstractPackage[ParsedDataFullPacked]):
    """
    Full IMU data (raw data and orientations), encoded as fixed-point numbers and with 8 samples per package.

    This is the main package type for recording and transmitting raw data.

    Note: The orientation is only provided for the first sample because the remaining values can be extrapolated from
    the first orientation sample and the gyroscope measurements. See the Python SDK code of the ``parse`` method for an
    implementation.

    **Fields**:

    * **timestamp**: *int64* -- Timestamp (in nanoseconds) of the first sample.
    * **gyr**: *int16[24]* -- 8 gyroscope measurements, 2000°/s full range.
    * **acc**: *int16[24]* -- 8 accelerometer measurements, 16*9.81 m/s² full range.
    * **mag**: *int16[24]* -- 8 magnetometer measurements, in µT/16.
    * **quat**: *uint64* -- 6D orientation for first sample, including rest+magDist flags.
    * **delta**: *int16* -- Heading offset for first sample. The 9D orientation can be calculated from ``quat`` and
      ``delta``.
    * **errorFlags**: *uint8* -- Error flags.

    8 + 24*2 + 24*2 + 24*2 + 8 + 2 + 1 = 163 bytes

    200 Hz: 32600 bytes/s

    100 Hz: 16300 bytes/s

    50 Hz: 8150 bytes/s

    25 Hz: 4075 bytes/s

    10 Hz: 1630 bytes/s

    1 Hz: 163 bytes/s
    """
    timestamp: int
    """int64; Timestamp (in nanoseconds) of the first sample."""
    gyr: ctypes.Array[ctypes.c_int16]
    """int16[24]; 8 gyroscope measurements, 2000°/s full range."""
    acc: ctypes.Array[ctypes.c_int16]
    """int16[24]; 8 accelerometer measurements, 16*9.81 m/s² full range."""
    mag: ctypes.Array[ctypes.c_int16]
    """int16[24]; 8 magnetometer measurements, in µT/16."""
    quat: int
    """uint64; 6D orientation for first sample, including rest+magDist flags."""
    delta: int
    """int16; Heading offset for first sample. The 9D orientation can be calculated from ``quat`` and ``delta``."""
    errorFlags: int
    """uint8; Error flags."""

    def __init__(
        self,
        timestamp: int = ...,
        gyr: ctypes.Array[ctypes.c_int16] = ...,
        acc: ctypes.Array[ctypes.c_int16] = ...,
        mag: ctypes.Array[ctypes.c_int16] = ...,
        quat: int = ...,
        delta: int = ...,
        errorFlags: int = ...,
    ) -> None: ...


class DataFullPacked200Hz(DataFullPacked):
    header = SensorHeader.DATA_FULL_PACKED_200HZ
    """SensorHeader.DATA_FULL_PACKED_200HZ (0x0221)"""
    rate = 200


class DataFullPacked100Hz(DataFullPacked):
    header = SensorHeader.DATA_FULL_PACKED_100HZ
    """SensorHeader.DATA_FULL_PACKED_100HZ (0x0222)"""
    rate = 100


class DataFullPacked50Hz(DataFullPacked):
    header = SensorHeader.DATA_FULL_PACKED_50HZ
    """SensorHeader.DATA_FULL_PACKED_50HZ (0x0223)"""
    rate = 50


class DataFullPacked25Hz(DataFullPacked):
    header = SensorHeader.DATA_FULL_PACKED_25HZ
    """SensorHeader.DATA_FULL_PACKED_25HZ (0x0224)"""
    rate = 25


class DataFullPacked10Hz(DataFullPacked):
    header = SensorHeader.DATA_FULL_PACKED_10HZ
    """SensorHeader.DATA_FULL_PACKED_10HZ (0x0225)"""
    rate = 10


class DataFullPacked1Hz(DataFullPacked):
    header = SensorHeader.DATA_FULL_PACKED_1HZ
    """SensorHeader.DATA_FULL_PACKED_1HZ (0x0226)"""
    rate = 1


class ParsedDataFull6DPacked(TypedDict):
    timestamp: np.ndarray[tuple[Literal[8], Literal[1]], np.dtype[np.float64]]
    gyr: np.ndarray[tuple[Literal[8], Literal[3]], np.dtype[np.float64]]
    acc: np.ndarray[tuple[Literal[8], Literal[3]], np.dtype[np.float64]]
    quat: np.ndarray[tuple[Literal[8], Literal[4]], np.dtype[np.float64]]
    quat9D: np.ndarray[tuple[Literal[8], Literal[4]], np.dtype[np.float64]]
    delta: np.ndarray[tuple[Literal[8], Literal[1]], np.dtype[np.float64]]
    restDetected: np.ndarray[tuple[Literal[8], Literal[1]], np.dtype[np.bool]]
    magDistDetected: np.ndarray[tuple[Literal[8], Literal[1]], np.dtype[np.bool]]
    errorFlags: np.ndarray[tuple[Literal[8], Literal[1]], np.dtype[np.uint8]]


class DataFull6DPacked(AbstractPackage[ParsedDataFull6DPacked]):
    """
    Variant of ``DataFullPacked`` that does not include magnetometer data. See ``DataFullPacked`` for more details.

    Set ``disableMagData`` to true in the measurement mode to generate this package instead of ``DataFullPacked``.

    Note: Even with magnetometer data output disabled, this package still contains the full 6D and 9D orientations.

    **Fields**:

    * **timestamp**: *int64* -- Timestamp (in nanoseconds) of the first sample.
    * **gyr**: *int16[24]* -- 8 gyroscope measurements, 2000°/s full range.
    * **acc**: *int16[24]* -- 8 accelerometer measurements, 16*9.81 m/s² full range.
    * **quat**: *uint64* -- 6D orientation for first sample, including rest+magDist flags.
    * **delta**: *int16* -- Heading offset for first sample. The 9D orientation can be calculated from ``quat`` and
      ``delta``.
    * **errorFlags**: *uint8* -- Error flags.

    8 + 24*2 + 24*2 + 8 + 2 + 1 = 115 bytes

    200 Hz: 23000 bytes/s

    100 Hz: 11500 bytes/s

    50 Hz: 5750 bytes/s

    25 Hz: 2875 bytes/s

    10 Hz: 1150 bytes/s

    1 Hz: 115 bytes/s
    """
    timestamp: int
    """int64; Timestamp (in nanoseconds) of the first sample."""
    gyr: ctypes.Array[ctypes.c_int16]
    """int16[24]; 8 gyroscope measurements, 2000°/s full range."""
    acc: ctypes.Array[ctypes.c_int16]
    """int16[24]; 8 accelerometer measurements, 16*9.81 m/s² full range."""
    quat: int
    """uint64; 6D orientation for first sample, including rest+magDist flags."""
    delta: int
    """int16; Heading offset for first sample. The 9D orientation can be calculated from ``quat`` and ``delta``."""
    errorFlags: int
    """uint8; Error flags."""

    def __init__(
        self,
        timestamp: int = ...,
        gyr: ctypes.Array[ctypes.c_int16] = ...,
        acc: ctypes.Array[ctypes.c_int16] = ...,
        quat: int = ...,
        delta: int = ...,
        errorFlags: int = ...,
    ) -> None: ...


class DataFull6DPacked200Hz(DataFull6DPacked):
    header = SensorHeader.DATA_FULL_6D_PACKED_200HZ
    """SensorHeader.DATA_FULL_6D_PACKED_200HZ (0x0231)"""
    rate = 200


class DataFull6DPacked100Hz(DataFull6DPacked):
    header = SensorHeader.DATA_FULL_6D_PACKED_100HZ
    """SensorHeader.DATA_FULL_6D_PACKED_100HZ (0x0232)"""
    rate = 100


class DataFull6DPacked50Hz(DataFull6DPacked):
    header = SensorHeader.DATA_FULL_6D_PACKED_50HZ
    """SensorHeader.DATA_FULL_6D_PACKED_50HZ (0x0233)"""
    rate = 50


class DataFull6DPacked25Hz(DataFull6DPacked):
    header = SensorHeader.DATA_FULL_6D_PACKED_25HZ
    """SensorHeader.DATA_FULL_6D_PACKED_25HZ (0x0234)"""
    rate = 25


class DataFull6DPacked10Hz(DataFull6DPacked):
    header = SensorHeader.DATA_FULL_6D_PACKED_10HZ
    """SensorHeader.DATA_FULL_6D_PACKED_10HZ (0x0235)"""
    rate = 10


class DataFull6DPacked1Hz(DataFull6DPacked):
    header = SensorHeader.DATA_FULL_6D_PACKED_1HZ
    """SensorHeader.DATA_FULL_6D_PACKED_1HZ (0x0236)"""
    rate = 1


class ParsedDataFullFixed(TypedDict):
    timestamp: int
    gyr: np.ndarray[tuple[Literal[3]], np.dtype[np.float64]]
    acc: np.ndarray[tuple[Literal[3]], np.dtype[np.float64]]
    mag: np.ndarray[tuple[Literal[3]], np.dtype[np.float64]]
    quat: np.ndarray[tuple[Literal[4]], np.dtype[np.float64]]
    quat9D: np.ndarray[tuple[Literal[4]], np.dtype[np.float64]]
    delta: float
    restDetected: bool
    magDistDetected: bool
    errorFlags: int


class DataFullFixed(AbstractPackage[ParsedDataFullFixed]):
    """
    Single sample containing full IMU data (raw data and orientations), encoded as fixed-point numbers.

    This can be useful for streaming or recording at low sampling rates. In most cases, ``DataFullPacked`` is the better
    option.

    **Fields**:

    * **timestamp**: *int64* -- Timestamp (in nanoseconds).
    * **gyr**: *int16[3]* -- Gyroscope measurement, 2000°/s full range.
    * **acc**: *int16[3]* -- Accelerometer measurement, 16*9.81 m/s² full range.
    * **mag**: *int16[3]* -- Magnetometer measurement, in µT/16.
    * **quat**: *uint64* -- 6D orientation, including rest+magDist flags.
    * **delta**: *int16* -- Heading offset. The 9D orientation can be calculated from ``quat`` and ``delta``.
    * **errorFlags**: *uint8* -- Error flags.

    8 + 3*2 + 3*2 + 3*2 + 8 + 2 + 1 = 37 bytes

    200 Hz: 7400 bytes/s

    100 Hz: 3700 bytes/s

    50 Hz: 1850 bytes/s

    25 Hz: 925 bytes/s

    10 Hz: 370 bytes/s

    1 Hz: 37 bytes/s
    """
    timestamp: int
    """int64; Timestamp (in nanoseconds)."""
    gyr: ctypes.Array[ctypes.c_int16]
    """int16[3]; Gyroscope measurement, 2000°/s full range."""
    acc: ctypes.Array[ctypes.c_int16]
    """int16[3]; Accelerometer measurement, 16*9.81 m/s² full range."""
    mag: ctypes.Array[ctypes.c_int16]
    """int16[3]; Magnetometer measurement, in µT/16."""
    quat: int
    """uint64; 6D orientation, including rest+magDist flags."""
    delta: int
    """int16; Heading offset. The 9D orientation can be calculated from ``quat`` and ``delta``."""
    errorFlags: int
    """uint8; Error flags."""

    def __init__(
        self,
        timestamp: int = ...,
        gyr: ctypes.Array[ctypes.c_int16] = ...,
        acc: ctypes.Array[ctypes.c_int16] = ...,
        mag: ctypes.Array[ctypes.c_int16] = ...,
        quat: int = ...,
        delta: int = ...,
        errorFlags: int = ...,
    ) -> None: ...


class DataFullFixed200Hz(DataFullFixed):
    header = SensorHeader.DATA_FULL_FIXED_200HZ
    """SensorHeader.DATA_FULL_FIXED_200HZ (0x0241)"""
    rate = 200


class DataFullFixed100Hz(DataFullFixed):
    header = SensorHeader.DATA_FULL_FIXED_100HZ
    """SensorHeader.DATA_FULL_FIXED_100HZ (0x0242)"""
    rate = 100


class DataFullFixed50Hz(DataFullFixed):
    header = SensorHeader.DATA_FULL_FIXED_50HZ
    """SensorHeader.DATA_FULL_FIXED_50HZ (0x0243)"""
    rate = 50


class DataFullFixed25Hz(DataFullFixed):
    header = SensorHeader.DATA_FULL_FIXED_25HZ
    """SensorHeader.DATA_FULL_FIXED_25HZ (0x0244)"""
    rate = 25


class DataFullFixed10Hz(DataFullFixed):
    header = SensorHeader.DATA_FULL_FIXED_10HZ
    """SensorHeader.DATA_FULL_FIXED_10HZ (0x0245)"""
    rate = 10


class DataFullFixed1Hz(DataFullFixed):
    header = SensorHeader.DATA_FULL_FIXED_1HZ
    """SensorHeader.DATA_FULL_FIXED_1HZ (0x0246)"""
    rate = 1


class DataFullFixedRt(DataFullFixed):
    header = SensorHeader.DATA_FULL_FIXED_RT
    """SensorHeader.DATA_FULL_FIXED_RT (0x0247)"""


class ParsedDataFull6DFixed(TypedDict):
    timestamp: int
    gyr: np.ndarray[tuple[Literal[3]], np.dtype[np.float64]]
    acc: np.ndarray[tuple[Literal[3]], np.dtype[np.float64]]
    quat: np.ndarray[tuple[Literal[4]], np.dtype[np.float64]]
    quat9D: np.ndarray[tuple[Literal[4]], np.dtype[np.float64]]
    delta: float
    restDetected: bool
    magDistDetected: bool
    errorFlags: int


class DataFull6DFixed(AbstractPackage[ParsedDataFull6DFixed]):
    """
    Variant of ``DataFullFixed`` that does not include magnetometer data. See ``DataFullFixed`` for more details.

    Set ``disableMagData`` to true in the measurement mode to generate this package instead of ``DataFullFixed``.

    Note: Even with magnetometer data output disabled, this package still contains the full 6D and 9D orientations.

    **Fields**:

    * **timestamp**: *int64* -- Timestamp (in nanoseconds).
    * **gyr**: *int16[3]* -- Gyroscope measurement, 2000°/s full range.
    * **acc**: *int16[3]* -- Accelerometer measurement, 16*9.81 m/s² full range.
    * **quat**: *uint64* -- 6D orientation, including rest+magDist flags.
    * **delta**: *int16* -- Heading offset. The 9D orientation can be calculated from ``quat`` and ``delta``.
    * **errorFlags**: *uint8* -- Error flags.

    8 + 3*2 + 3*2 + 8 + 2 + 1 = 31 bytes

    200 Hz: 6200 bytes/s

    100 Hz: 3100 bytes/s

    50 Hz: 1550 bytes/s

    25 Hz: 775 bytes/s

    10 Hz: 310 bytes/s

    1 Hz: 31 bytes/s
    """
    timestamp: int
    """int64; Timestamp (in nanoseconds)."""
    gyr: ctypes.Array[ctypes.c_int16]
    """int16[3]; Gyroscope measurement, 2000°/s full range."""
    acc: ctypes.Array[ctypes.c_int16]
    """int16[3]; Accelerometer measurement, 16*9.81 m/s² full range."""
    quat: int
    """uint64; 6D orientation, including rest+magDist flags."""
    delta: int
    """int16; Heading offset. The 9D orientation can be calculated from ``quat`` and ``delta``."""
    errorFlags: int
    """uint8; Error flags."""

    def __init__(
        self,
        timestamp: int = ...,
        gyr: ctypes.Array[ctypes.c_int16] = ...,
        acc: ctypes.Array[ctypes.c_int16] = ...,
        quat: int = ...,
        delta: int = ...,
        errorFlags: int = ...,
    ) -> None: ...


class DataFull6DFixed200Hz(DataFull6DFixed):
    header = SensorHeader.DATA_FULL_6D_FIXED_200HZ
    """SensorHeader.DATA_FULL_6D_FIXED_200HZ (0x0251)"""
    rate = 200


class DataFull6DFixed100Hz(DataFull6DFixed):
    header = SensorHeader.DATA_FULL_6D_FIXED_100HZ
    """SensorHeader.DATA_FULL_6D_FIXED_100HZ (0x0252)"""
    rate = 100


class DataFull6DFixed50Hz(DataFull6DFixed):
    header = SensorHeader.DATA_FULL_6D_FIXED_50HZ
    """SensorHeader.DATA_FULL_6D_FIXED_50HZ (0x0253)"""
    rate = 50


class DataFull6DFixed25Hz(DataFull6DFixed):
    header = SensorHeader.DATA_FULL_6D_FIXED_25HZ
    """SensorHeader.DATA_FULL_6D_FIXED_25HZ (0x0254)"""
    rate = 25


class DataFull6DFixed10Hz(DataFull6DFixed):
    header = SensorHeader.DATA_FULL_6D_FIXED_10HZ
    """SensorHeader.DATA_FULL_6D_FIXED_10HZ (0x0255)"""
    rate = 10


class DataFull6DFixed1Hz(DataFull6DFixed):
    header = SensorHeader.DATA_FULL_6D_FIXED_1HZ
    """SensorHeader.DATA_FULL_6D_FIXED_1HZ (0x0256)"""
    rate = 1


class ParsedDataFullFloat200Hz(TypedDict):
    timestamp: int
    gyr: np.ndarray[tuple[Literal[3]], np.dtype[np.float64]]
    acc: np.ndarray[tuple[Literal[3]], np.dtype[np.float64]]
    mag: np.ndarray[tuple[Literal[3]], np.dtype[np.float64]]
    quat: np.ndarray[tuple[Literal[4]], np.dtype[np.float64]]
    quat9D: np.ndarray[tuple[Literal[4]], np.dtype[np.float64]]
    delta: float
    restDetected: bool
    magDistDetected: bool
    errorFlags: int


class DataFullFloat200Hz(AbstractPackage[ParsedDataFullFloat200Hz]):
    """
    Single sample containing full IMU data (raw data and orientations) at 200 Hz, encoded as 32-bit floating point
    numbers.

    Unlike the other data packages, this package is not packed and included padding bytes.

    Note: In most applications, the more efficient ``DataFullPacked`` or ``DataFullFixed`` packages should be prefered.

    **Fields**:

    * **timestamp**: *int64* -- Timestamp (in nanoseconds).
    * **gyr**: *float[3]* -- Gyroscope measurement in rad/s.
    * **acc**: *float[3]* -- Accelerometer measurement in m/s².
    * **mag**: *float[3]* -- Magnetometer measurement in µT.
    * **quat**: *float[4]* -- 6D orientation quaternion (w, x, y, z).
    * **delta**: *float* -- Heading offset in rad. The 9D orientation can be calculated from ``quat`` and ``delta``.
    * **restDetected**: *bool* -- Indicates if sensor is at rest.
    * **magDistDetected**: *bool* -- Indicates if magnetic disturbance is detected.
    * **errorFlags**: *uint8* -- Error flags.

    8 + 3*4 + 3*4 + 3*4 + 4*4 + 4 + 1 + 1 + 1 = 67 bytes (+ padding)
    """
    header = SensorHeader.DATA_FULL_FLOAT_200HZ
    """SensorHeader.DATA_FULL_FLOAT_200HZ (0x0261)"""

    timestamp: int
    """int64; Timestamp (in nanoseconds)."""
    gyr: ctypes.Array[ctypes.c_float]
    """float[3]; Gyroscope measurement in rad/s."""
    acc: ctypes.Array[ctypes.c_float]
    """float[3]; Accelerometer measurement in m/s²."""
    mag: ctypes.Array[ctypes.c_float]
    """float[3]; Magnetometer measurement in µT."""
    quat: ctypes.Array[ctypes.c_float]
    """float[4]; 6D orientation quaternion (w, x, y, z)."""
    delta: float
    """float; Heading offset in rad. The 9D orientation can be calculated from ``quat`` and ``delta``."""
    restDetected: bool
    """bool; Indicates if sensor is at rest."""
    magDistDetected: bool
    """bool; Indicates if magnetic disturbance is detected."""
    errorFlags: int
    """uint8; Error flags."""

    def __init__(
        self,
        timestamp: int = ...,
        gyr: ctypes.Array[ctypes.c_float] = ...,
        acc: ctypes.Array[ctypes.c_float] = ...,
        mag: ctypes.Array[ctypes.c_float] = ...,
        quat: ctypes.Array[ctypes.c_float] = ...,
        delta: float = ...,
        restDetected: bool = ...,
        magDistDetected: bool = ...,
        errorFlags: int = ...,
    ) -> None: ...


class ParsedDataQuatPacked(TypedDict):
    timestamp: np.ndarray[tuple[Literal[20], Literal[1]], np.dtype[np.float64]]
    quat: np.ndarray[tuple[Literal[20], Literal[4]], np.dtype[np.float64]]
    quat9D: np.ndarray[tuple[Literal[20], Literal[4]], np.dtype[np.float64]]
    delta: np.ndarray[tuple[Literal[20], Literal[1]], np.dtype[np.float64]]
    restDetected: np.ndarray[tuple[Literal[20], Literal[1]], np.dtype[np.bool]]
    magDistDetected: np.ndarray[tuple[Literal[20], Literal[1]], np.dtype[np.bool]]
    errorFlags: np.ndarray[tuple[Literal[20], Literal[1]], np.dtype[np.uint8]]


class DataQuatPacked(AbstractPackage[ParsedDataQuatPacked]):
    """
    Orientation data, encoded as fixed-point numbers and with 20 samples per package.

    This is the main package type for recording and transmitting orientation data.

    **Fields**:

    * **timestamp**: *int64* -- Timestamp (in nanoseconds) of the first sample.
    * **quat**: *uint64[20]* -- 6D orientation samples, including rest+magDist flags.
    * **delta**: *int16[20]* -- Heading offset. The 9D orientation can be calculated from ``quat`` and ``delta``.
    * **errorFlags**: *uint8[20]* -- Error flags.

    8 + 20*8 + 20*2 + 20 = 228 bytes

    200 Hz: 45600 bytes/s

    100 Hz: 22800 bytes/s

    50 Hz: 11400 bytes/s

    25 Hz: 5700 bytes/s

    10 Hz: 2280 bytes/s

    1 Hz: 228 bytes/s
    """
    timestamp: int
    """int64; Timestamp (in nanoseconds) of the first sample."""
    quat: ctypes.Array[ctypes.c_uint64]
    """uint64[20]; 6D orientation samples, including rest+magDist flags."""
    delta: ctypes.Array[ctypes.c_int16]
    """int16[20]; Heading offset. The 9D orientation can be calculated from ``quat`` and ``delta``."""
    errorFlags: ctypes.Array[ctypes.c_uint8]
    """uint8[20]; Error flags."""

    def __init__(
        self,
        timestamp: int = ...,
        quat: ctypes.Array[ctypes.c_uint64] = ...,
        delta: ctypes.Array[ctypes.c_int16] = ...,
        errorFlags: ctypes.Array[ctypes.c_uint8] = ...,
    ) -> None: ...


class DataQuatPacked200Hz(DataQuatPacked):
    header = SensorHeader.DATA_QUAT_PACKED_200HZ
    """SensorHeader.DATA_QUAT_PACKED_200HZ (0x0271)"""
    rate = 200


class DataQuatPacked100Hz(DataQuatPacked):
    header = SensorHeader.DATA_QUAT_PACKED_100HZ
    """SensorHeader.DATA_QUAT_PACKED_100HZ (0x0272)"""
    rate = 100


class DataQuatPacked50Hz(DataQuatPacked):
    header = SensorHeader.DATA_QUAT_PACKED_50HZ
    """SensorHeader.DATA_QUAT_PACKED_50HZ (0x0273)"""
    rate = 50


class DataQuatPacked25Hz(DataQuatPacked):
    header = SensorHeader.DATA_QUAT_PACKED_25HZ
    """SensorHeader.DATA_QUAT_PACKED_25HZ (0x0274)"""
    rate = 25


class DataQuatPacked10Hz(DataQuatPacked):
    header = SensorHeader.DATA_QUAT_PACKED_10HZ
    """SensorHeader.DATA_QUAT_PACKED_10HZ (0x0275)"""
    rate = 10


class DataQuatPacked1Hz(DataQuatPacked):
    header = SensorHeader.DATA_QUAT_PACKED_1HZ
    """SensorHeader.DATA_QUAT_PACKED_1HZ (0x0276)"""
    rate = 1


class ParsedDataQuatFixed(TypedDict):
    timestamp: int
    quat: np.ndarray[tuple[Literal[4]], np.dtype[np.float64]]
    quat9D: np.ndarray[tuple[Literal[4]], np.dtype[np.float64]]
    delta: float
    restDetected: bool
    magDistDetected: bool
    errorFlags: int


class DataQuatFixed(AbstractPackage[ParsedDataQuatFixed]):
    """
    Single orientation sample, encoded as fixed-point numbers.

    **Fields**:

    * **timestamp**: *int64* -- Timestamp (in nanoseconds).
    * **quat**: *uint64* -- 6D orientation, including rest+magDist flags.
    * **delta**: *int16* -- Heading offset. The 9D orientation can be calculated from ``quat`` and ``delta``.
    * **errorFlags**: *uint8* -- Error flags.

    8 + 8 + 2 + 1 = 19 bytes

    200 Hz: 3800 bytes/s

    100 Hz: 1900 bytes/s

    50 Hz: 950 bytes/s

    25 Hz: 475 bytes/s

    10 Hz: 190 bytes/s

    1 Hz: 19 bytes/s
    """
    timestamp: int
    """int64; Timestamp (in nanoseconds)."""
    quat: int
    """uint64; 6D orientation, including rest+magDist flags."""
    delta: int
    """int16; Heading offset. The 9D orientation can be calculated from ``quat`` and ``delta``."""
    errorFlags: int
    """uint8; Error flags."""

    def __init__(
        self,
        timestamp: int = ...,
        quat: int = ...,
        delta: int = ...,
        errorFlags: int = ...,
    ) -> None: ...


class DataQuatFixed200Hz(DataQuatFixed):
    header = SensorHeader.DATA_QUAT_FIXED_200HZ
    """SensorHeader.DATA_QUAT_FIXED_200HZ (0x0281)"""
    rate = 200


class DataQuatFixed100Hz(DataQuatFixed):
    header = SensorHeader.DATA_QUAT_FIXED_100HZ
    """SensorHeader.DATA_QUAT_FIXED_100HZ (0x0282)"""
    rate = 100


class DataQuatFixed50Hz(DataQuatFixed):
    header = SensorHeader.DATA_QUAT_FIXED_50HZ
    """SensorHeader.DATA_QUAT_FIXED_50HZ (0x0283)"""
    rate = 50


class DataQuatFixed25Hz(DataQuatFixed):
    header = SensorHeader.DATA_QUAT_FIXED_25HZ
    """SensorHeader.DATA_QUAT_FIXED_25HZ (0x0284)"""
    rate = 25


class DataQuatFixed10Hz(DataQuatFixed):
    header = SensorHeader.DATA_QUAT_FIXED_10HZ
    """SensorHeader.DATA_QUAT_FIXED_10HZ (0x0285)"""
    rate = 10


class DataQuatFixed1Hz(DataQuatFixed):
    header = SensorHeader.DATA_QUAT_FIXED_1HZ
    """SensorHeader.DATA_QUAT_FIXED_1HZ (0x0286)"""
    rate = 1


class DataQuatFixedRt(DataQuatFixed):
    header = SensorHeader.DATA_QUAT_FIXED_RT
    """SensorHeader.DATA_QUAT_FIXED_RT (0x0287)"""


class ParsedDataQuatFloat(TypedDict):
    timestamp: int
    quat: np.ndarray[tuple[Literal[4]], np.dtype[np.float64]]
    quat9D: np.ndarray[tuple[Literal[4]], np.dtype[np.float64]]
    delta: float
    restDetected: bool
    magDistDetected: bool
    errorFlags: int


class DataQuatFloat(AbstractPackage[ParsedDataQuatFloat]):
    """
    Single orientation sample, encoded as 32-bit floating point numbers.

    Note: In most applications, the more efficient ``QuatFullPacked`` or ``QuatFullFixed`` packages should be prefered.

    **Fields**:

    * **timestamp**: *int64* -- Timestamp (in nanoseconds).
    * **quat**: *float[4]* -- 6D orientation quaternion (w, x, y, z).
    * **delta**: *float* -- Heading offset in rad. The 9D orientation can be calculated from ``quat`` and ``delta``.
    * **restDetected**: *bool* -- Indicates if sensor is at rest.
    * **magDistDetected**: *bool* -- Indicates if magnetic disturbance is detected.
    * **errorFlags**: *uint8* -- Error flags.

    8 + 4*4 + 4 + 1 + 1 + 1 = 31 bytes

    200 Hz: 6200 bytes/s

    100 Hz: 3100 bytes/s

    50 Hz: 1550 bytes/s

    25 Hz: 775 bytes/s

    10 Hz: 310 bytes/s

    1 Hz: 31 bytes/s
    """
    timestamp: int
    """int64; Timestamp (in nanoseconds)."""
    quat: ctypes.Array[ctypes.c_float]
    """float[4]; 6D orientation quaternion (w, x, y, z)."""
    delta: float
    """float; Heading offset in rad. The 9D orientation can be calculated from ``quat`` and ``delta``."""
    restDetected: bool
    """bool; Indicates if sensor is at rest."""
    magDistDetected: bool
    """bool; Indicates if magnetic disturbance is detected."""
    errorFlags: int
    """uint8; Error flags."""

    def __init__(
        self,
        timestamp: int = ...,
        quat: ctypes.Array[ctypes.c_float] = ...,
        delta: float = ...,
        restDetected: bool = ...,
        magDistDetected: bool = ...,
        errorFlags: int = ...,
    ) -> None: ...


class DataQuatFloat200Hz(DataQuatFloat):
    header = SensorHeader.DATA_QUAT_FLOAT_200HZ
    """SensorHeader.DATA_QUAT_FLOAT_200HZ (0x0291)"""
    rate = 200


class DataQuatFloat100Hz(DataQuatFloat):
    header = SensorHeader.DATA_QUAT_FLOAT_100HZ
    """SensorHeader.DATA_QUAT_FLOAT_100HZ (0x0292)"""
    rate = 100


class DataQuatFloat50Hz(DataQuatFloat):
    header = SensorHeader.DATA_QUAT_FLOAT_50HZ
    """SensorHeader.DATA_QUAT_FLOAT_50HZ (0x0293)"""
    rate = 50


class DataQuatFloat25Hz(DataQuatFloat):
    header = SensorHeader.DATA_QUAT_FLOAT_25HZ
    """SensorHeader.DATA_QUAT_FLOAT_25HZ (0x0294)"""
    rate = 25


class DataQuatFloat10Hz(DataQuatFloat):
    header = SensorHeader.DATA_QUAT_FLOAT_10HZ
    """SensorHeader.DATA_QUAT_FLOAT_10HZ (0x0295)"""
    rate = 10


class DataQuatFloat1Hz(DataQuatFloat):
    header = SensorHeader.DATA_QUAT_FLOAT_1HZ
    """SensorHeader.DATA_QUAT_FLOAT_1HZ (0x0296)"""
    rate = 1


class ParsedDataRawBurst(TypedDict):
    timestamp: np.ndarray[tuple[Literal[16], Literal[1]], np.dtype[np.int64]]
    gyr: np.ndarray[tuple[Literal[16], Literal[3]], np.dtype[np.float64]]
    acc: np.ndarray[tuple[Literal[16], Literal[3]], np.dtype[np.float64]]
    mag: np.ndarray[tuple[Literal[16], Literal[3]], np.dtype[np.float64]]
    errorFlags: np.ndarray[tuple[Literal[8], Literal[1]], np.dtype[np.uint8]]


class DataRawBurst(AbstractPackage[ParsedDataRawBurst]):
    """
    Raw data at ~1666 Hz of short high-frequency burst measurements.

    Each package contains 16 samples, i.e., packages are generated at ~104 Hz.

    **Fields**:

    * **timestamp**: *int64* -- Timestamp (in nanoseconds) of the first sample.
    * **gyr**: *int16[48]* -- 16 gyroscope measurements.
    * **acc**: *int16[48]* -- 16 accelerometer measurements.
    * **mag**: *int16[3]* -- Magnetometer measurement for first sample.
    * **errorFlags**: *uint8* -- Error flags.

    8 + 48*2 + 48*2 + 3*2 + 1 = 207 bytes
    """
    header = SensorHeader.DATA_RAW_BURST
    """SensorHeader.DATA_RAW_BURST (0x0300)"""

    timestamp: int
    """int64; Timestamp (in nanoseconds) of the first sample."""
    gyr: ctypes.Array[ctypes.c_int16]
    """int16[48]; 16 gyroscope measurements."""
    acc: ctypes.Array[ctypes.c_int16]
    """int16[48]; 16 accelerometer measurements."""
    mag: ctypes.Array[ctypes.c_int16]
    """int16[3]; Magnetometer measurement for first sample."""
    errorFlags: int
    """uint8; Error flags."""

    def __init__(
        self,
        timestamp: int = ...,
        gyr: ctypes.Array[ctypes.c_int16] = ...,
        acc: ctypes.Array[ctypes.c_int16] = ...,
        mag: ctypes.Array[ctypes.c_int16] = ...,
        errorFlags: int = ...,
    ) -> None: ...


class ParsedDataAccZBurst(TypedDict):
    timestamp: np.ndarray[tuple[Literal[64], Literal[1]], np.dtype[np.float64]]
    accZ: np.ndarray[tuple[Literal[64], Literal[1]], np.dtype[np.float64]]
    errorFlags: np.ndarray[tuple[Literal[64], Literal[1]], np.dtype[np.uint8]]


class DataAccZBurst(AbstractPackage[ParsedDataAccZBurst]):
    """
    Z-component of the accelerometer measurement at ~1666 Hz of short high-frequency burst measurements.

    Compared to the full burst mode, choosing this package type reduces the data rate but still allows for measurement
    of high-frequency vibrations orthogonal to the device surface.

    Each package contains 64 samples, i.e., packages are generated at ~26 Hz.

    **Fields**:

    * **timestamp**: *int64* -- Timestamp (in nanoseconds) of the first sample.
    * **accZ**: *int16[64]* -- 64 z-axis accelerometer measurements.
    * **errorFlags**: *uint8* -- Error flags.

    8 + 64*2 + 1 = 137 bytes
    """
    header = SensorHeader.DATA_ACCZ_BURST
    """SensorHeader.DATA_ACCZ_BURST (0x0301)"""

    timestamp: int
    """int64; Timestamp (in nanoseconds) of the first sample."""
    accZ: ctypes.Array[ctypes.c_int16]
    """int16[64]; 64 z-axis accelerometer measurements."""
    errorFlags: int
    """uint8; Error flags."""

    def __init__(
        self,
        timestamp: int = ...,
        accZ: ctypes.Array[ctypes.c_int16] = ...,
        errorFlags: int = ...,
    ) -> None: ...


class ParsedDataSyncTrigger(TypedDict):
    timestamp: int
    value: int


class DataSyncTrigger(AbstractPackage[ParsedDataSyncTrigger]):
    """
    Hardware synchronization event.

    When a rising or falling edge of the USB-C sideband use pin (SBU) is detected, a ``DataSyncTrigger`` package with
    the current sensor timestamp is generated. Those packages can be used for precise time synchronization between the
    sensors and other systems.

    **Fields**:

    * **timestamp**: *int64* -- Timestamp (in nanoseconds).
    * **value**: *uint8* -- 0 for falling edge, 1 for rising edge.

    8 + 1 = 9 bytes
    """
    header = SensorHeader.DATA_SYNC_TRIGGER
    """SensorHeader.DATA_SYNC_TRIGGER (0x0400)"""

    timestamp: int
    """int64; Timestamp (in nanoseconds)."""
    value: int
    """uint8; 0 for falling edge, 1 for rising edge."""

    def __init__(
        self,
        timestamp: int = ...,
        value: int = ...,
    ) -> None: ...


class ParsedDataFsFileCount(TypedDict):
    fileCount: int


class DataFsFileCount(AbstractPackage[ParsedDataFsFileCount]):
    """
    Number of files on the sensor.

    **Fields**:

    * **fileCount**: *uint16* -- Number of files.

    2 bytes
    """
    header = SensorHeader.DATA_FS_FILE_COUNT
    """SensorHeader.DATA_FS_FILE_COUNT (0x0501)"""

    fileCount: int
    """uint16; Number of files."""

    def __init__(
        self,
        fileCount: int = ...,
    ) -> None: ...


class ParsedDataFsFile(TypedDict):
    index: int
    filename: bytes
    size: int


class DataFsFile(AbstractPackage[ParsedDataFsFile]):
    """
    Information about a file on the sensor.

    **Fields**:

    * **index**: *uint16* -- Index.
    * **filename**: *char[65]* -- File name.
    * **size**: *uint32* -- File size in bytes.

    2 + 65 + 4 = 71 bytes
    """
    header = SensorHeader.DATA_FS_FILE
    """SensorHeader.DATA_FS_FILE (0x0502)"""

    index: int
    """uint16; Index."""
    filename: bytes
    """char[65]; File name."""
    size: int
    """uint32; File size in bytes."""

    def __init__(
        self,
        index: int = ...,
        filename: bytes = ...,
        size: int = ...,
    ) -> None: ...


class ParsedCmdFsGetBytes(TypedDict):
    filename: bytes
    startPos: int
    endPos: int


class CmdFsGetBytes(AbstractPackage[ParsedCmdFsGetBytes]):
    """
    Command to get bytes from a file on the sensor.

    **Fields**:

    * **filename**: *char[65]* -- File name.
    * **startPos**: *uint32* -- Start position in the file.
    * **endPos**: *uint32* -- End position in the file. Set to 0 to transfer the whole file.

    65 + 4 + 4 = 73 bytes
    """
    header = SensorHeader.CMD_FS_GET_BYTES
    """SensorHeader.CMD_FS_GET_BYTES (0x0503)"""

    filename: bytes
    """char[65]; File name."""
    startPos: int
    """uint32; Start position in the file."""
    endPos: int
    """uint32; End position in the file. Set to 0 to transfer the whole file."""

    def __init__(
        self,
        filename: bytes = ...,
        startPos: int = ...,
        endPos: int = ...,
    ) -> None: ...


class ParsedDataFsBytes(TypedDict):
    offset: int
    payload: bytes


class DataFsBytes(AbstractPackage[ParsedDataFsBytes]):
    """
    Chunk of bytes from a file on the sensor.

    **Fields**:

    * **offset**: *uint32* -- Offset in the file.
    * **payload**: *uint8[232]* -- Payload data (``MAX_PAYLOAD_SIZE`` - 4).

    4 + 232 = 236 bytes
    """
    header = SensorHeader.DATA_FS_BYTES
    """SensorHeader.DATA_FS_BYTES (0x0504)"""
    variable_size = True
    payload = bytes()

    offset: int
    """uint32; Offset in the file."""

    def __init__(
        self,
        offset: int = ...,
        payload: ctypes.Array[ctypes.c_uint8] = ...,
    ) -> None: ...


class ParsedDataFsFilename(TypedDict):
    filename: bytes


class DataFsFilename(AbstractPackage[ParsedDataFsFilename]):
    """
    This package contains a file name for filesystem operations, used by various commands.

    **Fields**:

    * **filename**: *char[65]* -- File name.

    65 bytes
    """
    filename: bytes
    """char[65]; File name."""

    def __init__(
        self,
        filename: bytes = ...,
    ) -> None: ...


class CmdFsGetSize(DataFsFilename):
    header = SensorHeader.CMD_FS_GET_SIZE
    """SensorHeader.CMD_FS_GET_SIZE (0x0507)"""


class CmdFsDeleteFile(DataFsFilename):
    header = SensorHeader.CMD_FS_DELETE_FILE
    """SensorHeader.CMD_FS_DELETE_FILE (0x0509)"""


class AckFsDeleteFile(DataFsFilename):
    header = SensorHeader.ACK_FS_DELETE_FILE
    """SensorHeader.ACK_FS_DELETE_FILE (0x050A)"""


class ParsedDataFsSize(TypedDict):
    filename: bytes
    fileSize: int


class DataFsSize(AbstractPackage[ParsedDataFsSize]):
    """
    Size of a file on the sensor.

    **Fields**:

    * **filename**: *char[65]* -- File name.
    * **fileSize**: *uint32* -- File size in bytes.

    65 + 4 = 69 bytes
    """
    header = SensorHeader.DATA_FS_SIZE
    """SensorHeader.DATA_FS_SIZE (0x0508)"""

    filename: bytes
    """char[65]; File name."""
    fileSize: int
    """uint32; File size in bytes."""

    def __init__(
        self,
        filename: bytes = ...,
        fileSize: int = ...,
    ) -> None: ...


class ParsedSensorError(TypedDict):
    errorCode: ErrorCode
    command: SensorHeader


class SensorError(AbstractPackage[ParsedSensorError]):
    """
    Represents an error that occurred on the sensor.

    **Fields**:

    * **errorCode**: *ErrorCode, uint8* -- Error code.
    * **command**: *SensorHeader, uint16* -- If applicable: the command that caused the error, otherwise: ``ERROR``.

    1 + 2 = 3 bytes
    """
    header = SensorHeader.ERROR
    """SensorHeader.ERROR (0xFFFF)"""

    errorCode: ErrorCode
    """ErrorCode; Error code."""
    command: SensorHeader
    """SensorHeader; If applicable: the command that caused the error, otherwise: ``ERROR``."""

    def __init__(
        self,
        errorCode: ErrorCode = ...,
        command: SensorHeader = ...,
    ) -> None: ...


class ParsedSensorSerialPackage(TypedDict):
    startByte: int
    crc32: int
    payloadSize: int
    header: SensorHeader


class SensorSerialPackage(AbstractPackage[ParsedSensorSerialPackage]):
    """
    Package frame including header, payload size, and checksum.

    **Fields**:

    * **startByte**: *uint8* -- Fixed 0x02 byte.
    * **crc32**: *uint32* -- Checksum calculated over ``header`` and ``payload``.
    * **payloadSize**: *uint8* -- Size of ``payload``, between 0 and 236.
    * **header**: *SensorHeader, uint16* -- Value that identifies the command or data package.
    * **payload**: *uint8[236]* -- Variable-length payload, between 0 and 236 bytes.

    1 + 4 + 1 + 2 + 236 = 244 bytes
    """
    startByte: int
    """uint8; Fixed 0x02 byte."""
    crc32: int
    """uint32; Checksum calculated over ``header`` and ``payload``."""
    payloadSize: int
    """uint8; Size of ``payload``, between 0 and 236."""
    header: SensorHeader
    """SensorHeader; Value that identifies the command or data package."""
    # + variable length payload, up until MAX_PAYLOAD_SIZE bytes

    def __init__(
        self,
        startByte: int = ...,
        crc32: int = ...,
        payloadSize: int = ...,
        header: SensorHeader = ...,
        payload: ctypes.Array[ctypes.c_uint8] = ...,
    ) -> None: ...
